export default {
  async fetch(request, env) {
    const json = (d, s = 200) =>
      new Response(JSON.stringify(d), {
        status: s,
        headers: { "content-type": "application/json" },
      });

    const url = new URL(request.url);
    if (url.pathname !== "/api/admin/init")
      return json({ ok: false, error: "Not found" }, 404);

    // --- protect with secret (remember # must be encoded as %23) ---
    const given = url.searchParams.get("secret") || "";
    const expected = env.ADMIN_INIT_SECRET || "Oury2933#";
    if (given !== expected) return json({ ok: false, error: "Forbidden" }, 403);

    // D1 binding (named DB in your Worker bindings)
    const db = env.DB || env.imarika;

    // Build SQL with join() so we’re certain it’s a single clean line
    const USERS_SQL = [
      "CREATE TABLE IF NOT EXISTS users (",
      "id INTEGER PRIMARY KEY,",
      "phone TEXT UNIQUE NOT NULL,",
      "full_name TEXT,",
      "id_number TEXT,",
      "pass_hash TEXT,",
      "role TEXT DEFAULT 'user',",
      "created_at INTEGER DEFAULT (strftime('%s','now'))",
      ");",
    ].join(" ");

    const TX_SQL = [
      "CREATE TABLE IF NOT EXISTS tx (",
      "id TEXT PRIMARY KEY,",
      "user_phone TEXT,",
      "type TEXT,",
      "detail TEXT,",
      "amount INTEGER,",
      "status TEXT,",
      "ts INTEGER",
      ");",
    ].join(" ");

    const TX_IDX_SQL =
      "CREATE INDEX IF NOT EXISTS idx_tx_phone_ts ON tx(user_phone, ts DESC);";

    try {
      // run schema (each statement separately)
      await db.exec(USERS_SQL);
      await db.exec(TX_SQL);
      await db.exec(TX_IDX_SQL);

      // seed/update admin user
      const phone = env.ADMIN_PHONE || "0715151010";
      const pass = env.ADMIN_PASS || "Oury2933#";
      const salt = env.PASS_SALT || "imarika-salt";

      const data = new TextEncoder().encode(`${salt}:${pass}`);
      const digest = await crypto.subtle.digest("SHA-256", data);
      const passHash = [...new Uint8Array(digest)]
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");

      await db
        .prepare(
          "INSERT INTO users (phone, full_name, id_number, pass_hash, role) VALUES (?, ?, ?, ?, 'admin') ON CONFLICT(phone) DO UPDATE SET pass_hash=excluded.pass_hash, role='admin'"
        )
        .bind(phone, "Imarika Admin", "ADMIN", passHash)
        .run();

      return json({ ok: true, message: "Schema ready, admin seeded.", phone });
    } catch (e) {
      // surface details to logs and response so we can see exactly what D1 says
      console.error("INIT ERROR:", e);
      return json(
        {
          ok: false,
          error: String(e),
          users_sql_len: USERS_SQL.length,
          tx_sql_len: TX_SQL.length,
        },
        500
      );
    }
  },
};
